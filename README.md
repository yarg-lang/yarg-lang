# yarg-lang

Yarg-Lang is a project to experiment with a dynamic language targetting microcontrollers. It has not yet made a release suitable for wide use.

Yarg aims to be a dedicated language for Microcontroller firmware development. It offers:

  - An interactive, on-device, REPL
  - Direct hardware access
  - Interupt based and multi-core multiprocessing
  - Modern language conveniences
  - Intended for production deployment

Microcontrollers (such as the $4 Raspberry Pi Pico, or the ESP32 family) are powerful computers, supporting multiple cores, many peripherals, and interrupts from those peripherals arriving at any time. We commonly develop software for them with languages like C or Python. C offers complete access to the system, but was designed when resources were very scarce, and it leaves a lot of work to the developer. Languages like Python offer more to the developer, but were designed with a general purpose computer in mind, and make access to hardware awkward (often they require a C driver). Yarg aims to provide the conveniences of languages like Python, alongside features that allow full access to hardware, so that C is not required to complete a project.

Of course, if you want to use modern language features, many general purpose languages are available in 'Micro', 'Tiny' or other cut-down versions of their implementation for microcontroller use. These implementations are faced with choices when the resources available do not support the same implementation possible in their original form. Do they try to be compatible (at what cost, if that is even possible?), or do they document a limitation compared to the original language? Yarg always prioritises microcontroller development, so all of the implementation choices suit production use for firmware.

Without clear multiprocessing support, language samples for starting projects must include polling, ("while true { sleep(x); do-stuff(); }"), which is wasteful of energy. How long is x? How often is do-stuff() actually needed? Modern microcontrollers are designed to be normally off, and to wake when something interesting is happening. Yarg is a language designed to eliminate wasteful polling like this from the start.

## Aims

  - A dynamic environment for on-device prototyping
  - Tooling to deploy working firmware to production
  - Sufficient static typing to reasonably add device specific code without writing C
  - Interop with C libraries available on device (such as USB, TCP/IP or WiFi)

Not (yet) intended for use. Additional documentation on the [wiki][wiki]

[wiki]: https://github.com/jhmcaleely/yarg-lang/wiki

| dir | Description |
| :--- | :--- |
| `cyarg/` | yarg implementation in C |
| `hostyarg/` | host tooling for yarg maintenance |
| `tools/` | Miscellaneous tools |
| `vscode-yarg/` | A VS Code Language Extension for Yarg |
| `yarg/specimen/` | Samples of Yarg |
| `yarg/specimen/conway-life-display` | A Yarg implemention of: [jhmcaleely/conway-life-display](https://github.com/jhmcaleely/conway-life-display) |
| `yarg/test/` | A Test Suite |

## Samples

These two samples illustrate Yarg:
  * `hello_led` can be typed at the REPL after boot, and directly manipulates registers as needed. 
  * `hello_button` uses Yarg channels (similar to go channels) to signal when an interrupt is generated by a button. The CPU can simply wait indefinately at idle for each button press.

### Hello LED

This sample turns on the builtin LED for a Pico, manipulating the registers directly.

`yarg/specimen/hello_led.ya`:
```
// the memory locations we need, see rp2040 datasheet: 
// https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf

const NUM_BANK0_GPIOS = 30;

place struct {
    uint32@0x014 gpio_out_set;
    uint32@0x024 gpio_oe_set;
    } @xd0000000 sio_hw;

place struct {
    struct {
        uint32 status;
        uint32 ctrl;
        }[NUM_BANK0_GPIOS] gpio;
    } @x40014000 io_bank0;

// the built in LED on a Pico.
const pico_led = 0d25;
const gpio_field = 0x1 << pico_led;

// minimally configure a GPIO, assuming core was reset first.
const GPIO_FUNC_SIO = 0d5;

poke io_bank0.gpio[pico_led].ctrl, GPIO_FUNC_SIO;
poke sio_hw.gpio_oe_set, gpio_field;


// turn the LED on.
poke sio_hw.gpio_out_set, gpio_field;
```

### Button Press

This sample creates a function that checks the events for the specified GPIO, and signals those on a channel the main coroutine can wait on.

Uses the 'gpio' library, which captures the direct register code above in a library of functions.

Assumes a button is wired to GPIO 2, and a LED+Resistor are connected to GPIO 3.

`yarg/specimen/hello_button.ya`:
``` 
import("gpio");

fun button_routine(gpio, chan) {

    const core = coreNum();

    fun gpio_response() {
        const events8 = peek(io_bank0.proc[core].ints[gpio >> 0d3]);
        const events = events8 >> (0d4 * (gpio % 0d8));

        // acknowledge the irq to the peripheral, and signal the requesting routine.
        gpio_acknowledge_irq(gpio, events);
        share(chan, events);
    }

    return make_routine(gpio_response, true);
}

// intialise a GPIO for an LED.
const led_io = 0d3;
gpio_init(led_io);
gpio_set_direction(led_io, GPIO_OUT);

// set up the response routine as an address we can install in the IRQ peripheral
const button_io = 0d2;
var button_channel = make_channel();
var button_handler_routine = button_routine(button_io, button_channel);
var button_handler_address = pin(button_handler_routine);

gpio_init(button_io);
irq_add_shared_handler(IO_IRQ_BANK0, button_handler_address, 0d0);

// enable interrupts for this gpio
gpio_set_irq_enabled(button_io, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);
irq_set_enabled(IO_IRQ_BANK0, true);


while (true) {
    bool state;
    var events = receive(button_channel);
    if (events == GPIO_IRQ_EDGE_FALL) {
        state = false;
    } else if (events == GPIO_IRQ_EDGE_RISE) {
        state = true;
    }
    gpio_put(led_io, state);
}
```

## Name

[Cornish Yarg](https://en.wikipedia.org/wiki/Cornish_Yarg) is a cheese I enjoy.
